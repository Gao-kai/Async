## 函数柯里化
函数柯里化是高阶函数应用及其重要的一部分，它的意思是部分求值，是由俄罗斯国数学家提出，后面由名为Curry的数理逻辑学家将其丰富和发展，因此函数柯里化也称之function currting。

函数柯里化的核心思想就是：一个curring的函数会接受一到多个参数，但是接受这些参数之后并不立即求值，而是返回另外一个函数，每次传入的参数都由于闭包的作用域而保护起来，等到函数真正的要执行的时候，将之前传入的所有参数一起取出然后执行，并返回最终结果。

关于函数柯里化需要注意的一点是：
1. 函数的参数可能是分多次传入的，并且有可能一次传递1个，有可能传2个，但无论每次传递多少个，这些参数都会被保护起来。

2. 函数的执行时机并不是固定的，你可以设定当函数某次传入的参数为空的时候取出之前传入的参数然后执行；也可以设定当传入的参数个数为多少的时候执行，这个是按照实际情况来的，也就是实现思路一致，但是具体实现细节有差异。


### 案例一
1. 题目
请你写一个函数sum，该函数可以实现如下需求：sum(1)(2,3)(4)的返回值是10

2. 分析
这道题是函数柯里化面试最常见也是最简单的一道，由题目可知当函数的参数累计到4个的时候，就立马计算并返回结果。这里是函数的连续调用。
```js
function sum(){
	return Array.from(arguments).reduce((a,b)=>a+b);
}

function currying(fn){
	let cacheParams = Array.from(arguments).slice(1);
	
	return function Temp(...innerArgs){
		// 保存每次进来的参数
		cacheParams = cacheParams.concat(innerArgs);
		// 参数满足条件就执行
		if(cacheParams.length >= 4){
			return fn.apply(null,cacheParams);
		}
		// 返回Temp引用 但是外层cacheParams的值不变
		return Temp;
	}
}
sum = currying(sum);
let res = sum(1)(2,3)(4);
console.log(res); // 10
```

### 案例二
1. 题目
请你写一个函数sum，该函数可以实现如下需求：
```bash
add(1);         1
add(1)(2);      3
add(1)(2)(3);   6
add(1)(2,3);    6
add(1,2)(3);    6
add(1,2,3);     6
add(1)(2)(3)(4) 10
```

2. 分析
这道题是上面那道题的加强版，难点在于要求传入的参数不定，但是要及时返回结果，解题的思路在于我们可以在原来的基础上将原本固定的参数4改为读取fn函数的形参个数来实现。

```js
function sum(){
	return Array.from(arguments).reduce((a,b)=>a+b);
}

// maxParamsLen指的是要柯里化的参数执行的最大参数个数
function currying(fn,maxParamsLen){
	let cacheParams = [];
	
	return function Temp(...innerArgs){
		// 保存每次进来的参数
		cacheParams = cacheParams.concat(innerArgs);
		// 参数满足条件就执行
		if(cacheParams.length >= maxParamsLen){
			return fn.apply(null,cacheParams);
		}
		// 返回Temp引用 但是外层cacheParams的值不变
		return Temp;
	}
}

sum = currying(sum,1);
console.log(sum(1)); // 1

sum = currying(sum,3);
console.log(sum(1,2)(3)); // 6
```

### 案例三
1. 题目
请你写一个函数sum，该函数可以实现如下需求：
```bash
sum(1);
sum(2,3);
sum(4); // 输出10
```


2. 分析
这道题是第一种思路的变化版本，注意从连续调用变成了分开调用，但是函数部分求值的思路不变，还是等参数到4个的时候执行。所以就用第一种方法就可以实现。
```js
function sum(){
	return Array.from(arguments).reduce((a,b)=>a+b);
}

function currying(fn){
	let cacheParams = Array.from(arguments).slice(1);
	
	return function Temp(...innerArgs){
		// 保存每次进来的参数
		cacheParams = cacheParams.concat(innerArgs);
		// 参数满足条件就执行
		if(cacheParams.length >= 4){
			return fn.apply(null,cacheParams);
		}
		// 返回Temp引用 但是外层cacheParams的值不变
		return Temp;
	}
}
sum = currying(sum);
sum(1);
sum(2,3);
let res = sum(4); // 输出10
console.log(res);
```